---
title: https通信原理
tags:
- https
categories:
- web
---

# 1.http的安全问题

安全通信一般包含以下四个原则：

- 机密性：即对数据加密，解决了窃听风险，因为即使被中间人窃听，由于数据是加密的，他也拿不到明文；
- 完整性：指数据在传输过程中没有被篡改，不多不少，保持原样，中途如果哪怕改了一个标点符号，接收方也能识别出来，从来判定接收报文不合法；
- 身份认证：确认对方的真实身份，这样就解决了冒充风险，用户不用担心访问的是某宝结果却在和钓鱼网站通信的问题；
- 不可否认: 即不可否认已发生的行为，比如小明向小红借了 1000 元，但没打借条，或者打了借条但没有签名，就会造成小红的资金损失。

但是http完全不符合安全通信的要求，它的问题来自于它是明文传输，主要风险来自于如下的“中间人攻击”：

- 窃听风险：中间人可以获取通信内容，由于是明文传输，所以中间人可以得知发送内容：

  ![](https://images-pigo.oss-cn-beijing.aliyuncs.com/20220604210206.png)

- 篡改风险：中间人可以篡改发送内容给对方：

  ![](https://images-pigo.oss-cn-beijing.aliyuncs.com/20220604210303.png)

- 冒充风险：中间人冒充目的网站进行钓鱼：

  ![](https://images-pigo.oss-cn-beijing.aliyuncs.com/20220604210557.png)

但是使用https就可以满足安全通信的四个原则。

https指的是http+ssl，具体可参考：[What is SSL](https://www.ssl.com/faqs/faq-what-is-ssl/)，注意，现在我们在https上使用的是TLS，只不过由于习惯，我们仍然称之为SSL。

# 2.加密算法

https中混合使用了对称加密和非对称加密，下面先了解一下这两种加密算法。

1. 对称加密

   参考：[Symmetric Key Encryption](https://www.cryptomathic.com/news-events/blog/symmetric-key-encryption-why-where-and-how-its-used-in-banking)

   使用对称加密的https通信过程如下：

   ![](https://images-pigo.oss-cn-beijing.aliyuncs.com/20220604212230.png)

   可见，通信双方使用相同的密钥来加密，常见的加密算法有DES、AES和3DES等，此时即使被中间人截获，也无法解密得到传输内容。

   不难得知，在这种情况下，会产生两个问题：

   - 双方有一个确定secret key的过程，此时数据还没有加密，如果这个时候被截获，那这个key就被中间人知道了，他就可以拿来解密后续发送的数据了；
   - 当用户访问多个不同服务时，会产生多个secret key，此时key的管理会是一个问题。

2. 非对称加密

   参考：[asymmetric cryptography](https://www.techtarget.com/searchsecurity/definition/asymmetric-cryptography)

   ![](https://images-pigo.oss-cn-beijing.aliyuncs.com/20220604213920.png)

   此时加密和解密使用一对public key和private key来完成。上图中服务器保存了私钥，将公钥发送给各个客户端，然后客户端使用公钥加密数据，被公钥加密后的数据只有私钥才能解开。常见的非对称加密算法有RSA算法。需要知道的是公钥加密只能使用私钥解密，同时私钥加密，也只能使用公钥解密。

   此种方式依然会产生的问题在于：

   - 如同对称加密中获取secret key的过程，如何获取正确的公钥信息。如果在一开始发送公钥的过程中被截获，中间人使用假冒的公钥来代替，则仍然会产生问题。

# 3.证书

参考：[WHAT IS AN SSL CERTIFICATE](https://www.digicert.com/what-is-an-ssl-certificate)

为了解决上面非对称加密中的问题，我们采用了证书的形式来将公钥发送给客户端。简单来说，就是将公钥信息加入到证书当中，证书由CA机构颁发。客户端访问服务时，服务端会将此证书发给客户端，客户端从证书中获取到公钥信息，再使用此公钥加密数据。那对于证书本身该如何保护见以下方面。

1. 如何防止篡改证书内容

   ![](https://images-pigo.oss-cn-beijing.aliyuncs.com/20220604220703.png)

   - 首先使用不可逆的摘要算法将证书明文部分生成摘要，然后CA使用它的秘钥对生成的摘要进行加密（也就是签名），也就是上图中最下面的签名内容。所以证书内容包括公钥和CA签名；
   - 客户端在得到证书后，使用相同的摘要算法对证书明文计算摘要，然后使用CA的公钥对签名解密得到摘要，把这两个结果的主要进行比较，如果一致的话，代表证书内容正常。

   分析以上流程可以得知，假设中间人修改了证书，由于客户端会使用CA公钥解密，此时得到的摘要结果不一致，或者无法解密，客户端就会认定连接非法。

   那客户端是怎么得到正确的CA公钥呢，其实，这里的公钥就是被操作系统信任的ROOT CA，这个证书一般由其他可信任途径得到。

2. 如何防止证书被掉包

   由于中间人可是可以向CA申请证书的，所以他可以通过申请证书来获取CA的公钥，从而截获通信数据，伪装成服务端应用发送自己的证书给客户端。想象一下这种情形：

   ~~~html
   client--> nginx --> https应用
   ~~~

   把nginx当做中间人，client访问https应用，但是nginx截获了访问数据，将自己的证书发给了客户端，冒充服务端和客户端通信，就可以得到客户端访问的一切信息。

   似乎这里是可行的，但是存在一个问题，客户端访问的域名是https应用的域名，但是中间人nginx的域名必然和https域名不用，所以客户端会通过验证证书上的域名是否和自己请求的域名一致，如果不一致，则会认定证书不安全。这是我们常见的一种浏览器报错现象。

3. 避免随意信任第三方ROOT CA

   假如中间人并没有向客户端要访问的CA机构申请证书，但是他伪造了自己的ROOT CA，并且欺骗用户将这个ROOT CA安装到了操作系统上，此时操作系统会默认信任这个ROOT CA。假如中间人伪造了相同域名的证书，则使用上面的域名是否相同来验证就失效了。

   所以我们不能随意信任不确定的第三方ROOT CA。

4. 证书链

   由于证书都是向ROOT CA申请的，但是全球的ROOT CA是有限的，所以为了能够及时响应证书申请，ROOT CA会向下级授权，它会向一级CA签名，以表明这个一级CA是被ROOT CA授权过了，其他层级也都是由上一层CA签名授权。这种情况下，客户端接收到的证书会包含整个证书信任链，客户端会逐级检查这些CA是否被信任，以下是一个二级CA的验证流程：

   - 客户端先使用ROOT CA的公钥解析一级证书得到一级CA证书的公钥和摘要验签；
   - 使用一级证书公钥解析二级级CA证书，拿到二级CA证书的公钥和摘要验签；
   - 使用二级证书公钥解析服务器证书，得到服务器的公钥和摘要验签，过程结束。

# 4.TLS握手

